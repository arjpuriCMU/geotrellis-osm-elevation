package geotrellis.vectortile

import java.nio.file.{Files, Paths}

import geotrellis.vector._

/** the companion object to the VectorTile class
  */
object VectorTile {
    /* make is so people don't have look else where for imports */
    type GeomType = vector_tile.Tile.GeomType.EnumVal
    val POINT = vector_tile.Tile.GeomType.POINT
    val LINESTRING = vector_tile.Tile.GeomType.LINESTRING
    val POLYGON = vector_tile.Tile.GeomType.POLYGON
}

/** a representation of a VectorTile; see:
  * https://github.com/mapbox/vector-tile-spec/tree/master/2.1
  *
  * @constructor from a set of (user-built) Layers
  * @param _layers the set of layers to build the tile from
  */
class VectorTile(val _layers: Set[Layer]) {

    val layers: Set[Layer] = _layers

    /** @constructor from the naively decoded protobuff; see:
      *              vectortile/vector_tile/VectorTile.scala
      * @param vector_tile the naively decoded tile
      */
    def this(vectorTile: vector_tile.Tile) {
       this(vectorTile.layers.map(
           (x: vector_tile.Tile.Layer) => new Layer(x)).toSet)
    }

    /** @constructor from a file name
      * @param filename the filename
      */
    def this(filename: String) {
        // http://stackoverflow.com/questions/7598135/
        this(vector_tile.Tile
                        .parseFrom(Files.readAllBytes(Paths.get(filename))))
    }

    def encode(filename: String) {
        // TODO Not Yet Implemented
        /* build an instance of the autogenerated case class to match this
         * instance, then use the ``writeTo'' function */
        /* only weird thing is mapping String -> Value to a sequence of Ints*/
    }

    /** extract all Geometries from the tile
      *
      * @return a list of all the geometries
      */
    def geometries(): Set[Geometry] = {
        return {
            for(layer <- layers; feature <- layer.features)
                yield feature.geometry
        }
    }

    /** extract Geometries from the tile that satisfy a predicate p
      *
      * @param p the predicate
      * @return a set of the geometries that satisfy the predicate
      */
     def filteredGeometries(p: (Layer, Feature) => Boolean): Set[Geometry] = {
        return {
            for(layer <- layers; feature <- layer.features
                 if p(layer, feature))
                yield feature.geometry
        }
    }

    /** extract the Geometries of this tile by type
      *
      * @param geomType the type of geometry to filter on
      * @return a set of all the geometries of that type
      */
    def geometriesByType(geomType: VectorTile.GeomType): Set[Geometry] = {
        return filteredGeometries(
            (layer, feature) => feature.geomType == geomType)
    }

    /** extract the Geometries of this tile by layer name
      *
      * @param name the names of the layers to extract from
      * @return a set of all the geometries in those layers
      */
    def geometriesByName(names: Set[String]): Set[Geometry] = {
        return filteredGeometries(
            (layer, feature) => names contains layer.name)
    }

    /* TODO there are a lot more convenience functions...
     * eg. filter by tags 
     * (has key, has keys, has key->val, has key->vals, etc)
     * but filteredGeometries is really powerful and should be used
     */

}

/** a representation of a VectorTile Layer
  *
  * @constructor from its fields; private in order to avoid errors with the
  * keys and vals fields
  * @param _version the version number (it really is an Int - check Spec)
  * @param _name the name of the layer
  * @param _extent the extent of the layer
  * @param _keys the sequence of keys (String)
  * @param _vals the sequence of values (Value)
  * @param _features the set of features
  */
class Layer(_version: Int, _name: String, _extent: Option[Int],
    _keys: Seq[String], _vals: Seq[Value], _features: Set[Feature]) {

    val version: Int = _version // originally unsigned
    val name: String = _name
    val extent: Int = _extent match { // originally unsigned
        case None => 4096 // default
        case Some(ext) => ext
    }
    val keys: Seq[String] = _keys
    val vals: Seq[Value] = _vals
    val features: Set[Feature] = _features

    /** @constructor autogenerate key and value sequences
      * @param _version the version number (it really is an Int - check Spec)
      * @param _name the name of the layer
      * @param _extent the extent of the layer
      * @param _features the set of features
      */
    def this(_version: Int, _name: String, _extent: Option[Int],
        _features: Set[Feature]) {
        // This isn't scala styled properly.
        this(_version, _name, _extent,
            _features.map(x => x.tags.keys.toSet)
                     .fold(Set.empty[String])(_ union _)
                     .toSeq,
            _features.map(x => x.tags.values.toSet)
                     .fold(Set.empty[Value])(_ union _)
                     .toSeq,
            _features)
    }

    /** @constructor from the naively decoded protobuff
      * @param layer the naively decoded layer
      */
    def this(layer: vector_tile.Tile.Layer) {
        // this is somewhat ugly. a more ``scala'' thing to do would be a
        // factory, but with the limited amount of time I have left, I'd
        // rather not deal with that.
        this(layer.version,
             layer.name,
             layer.extent,
             layer.keys,
             layer.values.map(v => new Value(v)),
             layer.features
                  .map((f: vector_tile.Tile.Feature) =>
                        new Feature(f, layer.keys,
                        layer.values.map(v => new Value(v)),
                        layer.extent match {
                            case None => 4096
                            case Some(ext) => ext
                        }))
                  .toSet
        )
    }

}

/** the companion object to Value */
object Value {

    case class InvalidValue(message: String) extends Exception(message)

}

/** the extracted value from the ``singleton'' tile value
  * does not support extensions yet
  *
  * @constructor from its fields
  * @param _value the tile value
  */
class Value private (_value: Any) {

    val value: Any = _value

    /** feels a little silly to doc each of these individually
      * they are just constructors for each of the allowable types */
    def this(_string: String) { this(_string.asInstanceOf[Any]) }
    def this(_float: Float) { this(_float.asInstanceOf[Any]) }
    def this(_double: Double) {this(_double.asInstanceOf[Any]) }
    def this(_int: Long) { this(_int.asInstanceOf[Any]) }
    // scala doesn't do uint or sint
    def this(_bool: Boolean) { this(_bool.asInstanceOf[Any]) }

    /** @constructor from naively decoded protobuff
      * @param _value the protobuff value
      */
    def this(_value: vector_tile.Tile.Value) {
        this({
            val vals = List(_value.stringValue,
                            _value.floatValue,
                            _value.doubleValue,
                            _value.intValue,
                            _value.uintValue,
                            _value.sintValue,
                            _value.boolValue).flatten
            if (vals.size == 1) {
                vals.head
            } else {
                throw Value.InvalidValue("Requires exactly one assignment")
            }
        })
    }

}

/** the companion object to Feature */
object Feature {

    /** pairs off the keys and value tags
      *
      * @param tags the sequence of tags
      * @param keys the sequence of keys
      * @param vals the sequence of vals
      * @return the map from the tag sequence
      */
    private def pair(tags: Seq[Int], keys: Seq[String], vals: Seq[Value]):
    Map[String, Value] = {

        var idx: Int = 0
        var paired: collection.mutable.Map[String, Value] =
            new collection.mutable.HashMap[String, Value]()
        while (idx < tags.length) {
            paired += (keys(tags(idx)) -> vals(tags(idx+1)))
            idx += 2
        }
        Map(paired.toList: _*)

    }

}

/** a representation of a VectorTile Feature
  * BE CAREFUL when building these!!!
  * the extent is chosen in the Layer, so there may be scaling issues if the
  * extent isn't verified
  *
  * @constructor from its fields
  * @param _id the id
  * @param _tags a map for the tags
  * @param _geomType the geometry type
  * @param _geometry the geometry
  */
class Feature(_id: Option[Long], _tags: Map[String, Value],
    _geomType: VectorTile.GeomType, _geometry: Geometry) {

    val id: Option[Long] = _id
    val tags: Map[String, Value] = _tags
    val geomType: VectorTile.GeomType = _geomType
    val geometry: Geometry = _geometry

    /** @constructor from a naively decoded protobuff
      * @param feature the naively decoded feature
      */
    def this(feature: vector_tile.Tile.Feature, keys: Seq[String],
        vals: Seq[Value], extent: Int) {
        this(feature.id, Feature.pair(feature.tags, keys, vals),
            feature.`type`.get, Command.parse(feature.`type`.get,
            extent, feature.geometry))
    }

}

